<!DOCTYPE html>
<html>
<head>
    <title>GraphQL Guide</title>
    <style>
        body {
            font-family: 'Times New Roman', serif;
            line-height: 1.6;
            margin: 40px;
            color: #333;
            font-size: 1.2em;
        }

        p {
            margin: 5px 0 5px 0;
        }
        
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            font-size: 2.5em;
            text-align: center;
            margin-bottom: 30px;
        }
        
        h2 {
            color: #34495e;
            border-bottom: 2px solid #e74c3c;
            padding-bottom: 8px;
            margin-top: 40px;
            font-size: 1.8em;
            margin-bottom: 5px;
        }
        
        h3 {
            color: #2c3e50;
            margin-top: 30px;
            font-size: 1.4em;
            margin-bottom: 5px;
        }
        
        h4 {
            color: green;
            margin-top: 25px;
            font-size: 1.2em;
            margin-bottom: 5px;
        }
        
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-left: 4px solid #3498db;
            margin: 30px 0;
        }
        
        .toc h2 {
            margin-top: 0;
            border-bottom: none;
        }
        
        .toc ol {
            padding-left: 20px;
        }
        
        .toc li {
            margin-bottom: 8px;
        }
        
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 1.2em;
        }
        
        pre {
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
        }
        
        pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        
        .example {
            background-color: #d4edda;
            padding: 15px;
            border-left: 4px solid #28a745;
            margin: 20px 0;
        }
        
        .warning {
            background-color: #f8d7da;
            padding: 15px;
            border-left: 4px solid #dc3545;
            margin: 20px 0;
        }
        
        blockquote {
            border-left: 4px solid #6c757d;
            padding-left: 20px;
            margin-left: 0;
            font-style: italic;
            color: #6c757d;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        
        .page-break {
            page-break-before: always;
        }
        
        .section-break {
            border-top: 1px solid #ddd;
            margin: 40px 0 20px 0;
            padding-top: 20px;
        }
        
        @media print {
            body {
                margin: 20px;
            }
            
            .page-break {
                page-break-before: always;
            }
            
            pre {
                page-break-inside: avoid;
            }
        }
    </style>
</head>
<body>
    <h1>Complete GraphQL Guide</h1>
    
    <div class="toc">
        <h2>Table of Contents</h2>
        <ol>
            <li><a href="#what-is-graphql">What is GraphQL?</a></li>
            <li><a href="#core-concepts">Core Concepts</a></li>
            <li><a href="#schema-type-system">Schema & Type System</a></li>
            <li><a href="#resolvers">Resolvers</a></li>
            <li><a href="#serving-graphql">Serving GraphQL</a></li>
            <li><a href="#pagination">Pagination</a></li>
            <li><a href="#implementations">Implementations</a></li>
            <li><a href="#advanced-features">Advanced Features</a></li>
            <li><a href="#best-practices">Best Practices</a></li>
            <li><a href="#final-takeaways">Final Takeaways</a></li>
        </ol>
    </div>

    <div class="section-break"></div>

    <h2 id="what-is-graphql">What is GraphQL?</h2>
    
    <p>GraphQL is a <strong>query language</strong> for your API and a <strong>runtime</strong> for executing those queries by using a type system you define for your data. It's not tied to any specific database or storage engine and is instead backed by your existing code and data.</p>

    <h3>Why GraphQL?</h3>
    <ul>
        <li><strong>Replaces REST</strong> in many cases</li>
        <li>Clients ask for <strong>exactly what they need</strong> → no over-fetching/under-fetching</li>
        <li><strong>Strong typing</strong> → better developer experience</li>
        <li><strong>Single endpoint</strong> instead of multiple REST routes</li>
        <li><strong>Real-time capabilities</strong> built-in</li>
    </ul>

    <h3>Problems GraphQL Solves</h3>
    
    <h4>Over-fetching</h4>
    <p>Getting more data than you need (e.g., a REST endpoint returns a full user object but you only need the username).</p>
    
    <h4>Under-fetching</h4>
    <p>Not getting enough data with a single request, forcing you to call multiple endpoints (e.g., fetch a user, then fetch their posts, then fetch their friends).</p>
    
    <h4>Rapid Product Development</h4>
    <p>Frontend developers can request exactly what they need without waiting for backend teams to create new, specific endpoints.</p>
    
    <h4>Thinking in Graphs</h4>
    <p>Instead of thinking about isolated endpoints (users, posts), you think about your data as a connected graph. You ask for a user, and you can traverse the graph to get their posts, and then the comments on those posts, all in one request.</p>

    <div class="example">
        <p><strong>Example:</strong> GraphQL models data as a <strong>graph</strong> — nodes (objects) connected by edges (relationships).</p>
    </div>

    <pre><code>{
  user(id: "1") {
    name
    posts {
      title
      author {
        name
      }
    }
  }
}</code></pre>

    <p>This represents a <strong>graph</strong>: User → Posts → Author.</p>

    <h3>GraphQL Architecture</h3>
    <ul>
        <li><strong>GraphQL on Frontend:</strong> Clients (React, iOS, Android) write queries to ask for specific data. They use a client like <strong>Apollo Client</strong> or <strong>Relay</strong> to handle caching, state management, and sending these queries.</li>
        <li><strong>GraphQL on Backend:</strong> The server defines a <strong>Schema</strong> (the type system) and <strong>Resolvers</strong> (functions that know how to fetch the data for each field).</li>
    </ul>

    <div class="highlight">
        <h4>REST vs GraphQL Example</h4>
        <p><strong>Instead of multiple REST calls:</strong></p>
        <pre><code># GET /api/users/1
# GET /api/users/1/posts
# GET /api/users/1/followers</code></pre>
        <p><strong>Single GraphQL query:</strong></p>
        <pre><code>query {
  user(id: 1) {
    name
    email
    posts {
      title
      content
    }
    followers {
      name
    }
  }
}</code></pre>
    </div>

    <div class="page-break"></div>

    <h2 id="core-concepts">Core Concepts</h2>
    <p>These are the three main operation types in GraphQL.</p>

    <h3>Queries → Read Operations</h3>
    <p>Queries are used to <strong>read</strong> or fetch data. (Equivalent to <strong>GET</strong> in REST).</p>

    <h4>Basic Query Example</h4>
    <pre><code>query {
  users {
    id
    name
    email
  }
}</code></pre>

    <h4>Query with Arguments</h4>
    <pre><code>query {
  user(id: "1") {
    name
    email
    posts(limit: 5) {
      title
      createdAt
    }
  }
}</code></pre>

    <h4>Query Components Breakdown</h4>
    
    <p><strong>Fields:</strong> <code>name</code>, <code>email</code>, <code>title</code>, <code>createdAt</code> are fields. You are asking for these specific properties.</p>
    
    <p><strong>Arguments:</strong> You can pass arguments to fields to be more specific. <code>id: "1"</code> is an argument to the <code>user</code> field. <code>limit: 5</code> is an argument to the <code>posts</code> field.</p>
    
    <p><strong>Variables:</strong> Instead of hardcoding <code>"1"</code>, you use variables to make queries dynamic.</p>
    <pre><code>query GetUser($userId: ID!) {
  user(id: $userId) {
    name
  }
}</code></pre>

    <p><strong>Aliases:</strong> If you need to ask for the same field with different arguments, you use aliases to avoid conflicts.</p>
    <pre><code>query {
  firstPost: post(id: "1") { title }
  secondPost: post(id: "2") { title }
}</code></pre>

    <p><strong>Fragments:</strong> Reusable sets of fields to avoid duplication.</p>
    <pre><code>fragment PostDetails on Post {
  title
  body
  author { name }
}

query {
  post1: post(id: "1") { ...PostDetails }
  post2: post(id: "2") { ...PostDetails }
}</code></pre>

    <p><strong>Directives:</strong> Dynamically change the structure of your query. <code>@include</code> and <code>@skip</code> are common.</p>
    <pre><code>query ($withEmail: Boolean!) {
  user(id: "1") {
    name
    email @include(if: $withEmail) # email is only fetched if $withEmail is true
  }
}</code></pre>

    <h3>Mutations → Write Operations</h3>
    <p>Mutations are used to <strong>write</strong> data (create, update, delete). (Equivalent to POST, PUT, PATCH, DELETE in REST).</p>

    <h4>Basic Mutation</h4>
    <pre><code>mutation {
  createUser(input: {
    name: "John Doe"
    email: "john@example.com"
  }) {
    id
    name
    email
  }
}</code></pre>

    <h4>Multiple Operations in Single Mutation</h4>
    <pre><code>mutation {
  createPost(input: {
    title: "GraphQL Guide"
    content: "Learning GraphQL..."
  }) {
    id
    title
  }
  
  updateUser(id: "123", input: {
    name: "Updated Name"
  }) {
    id
    name
  }
}</code></pre>

    <h3>Subscriptions → Real-time Updates</h3>
    <p>Subscriptions are used to get real-time updates pushed from the server. They are typically implemented using WebSockets.</p>

    <h4>Basic Subscription</h4>
    <pre><code>subscription {
  commentAdded(postId: "123") {
    id
    content
    author {
      name
    }
    createdAt
  }
}</code></pre>

    <div class="page-break"></div>

    <h2 id="schema-type-system">Schema & Type System</h2>
    <p>The schema is the <strong>contract</strong> between the client and the server. It defines all the available data and operations.</p>

    <h3>Basic Schema Definition</h3>
    <pre><code>type Query {
  user(id: ID!): User
  posts(limit: Int): [Post!]!
}

type Mutation {
  createPost(title: String!, body: String!): Post!
}

type User {
  id: ID!
  name: String!
  email: String!
  posts: [Post!]
}

type Post {
  id: ID!
  title: String!
  body: String!
  author: User!
}</code></pre>

    <h3>Schema Components</h3>

    <h4>Scalars</h4>
    <p>Built-in primitive types: <code>Int</code>, <code>Float</code>, <code>String</code>, <code>Boolean</code>, <code>ID</code> (a unique identifier).</p>
    
    <p><strong>Custom Scalars:</strong></p>
    <pre><code>scalar DateTime
scalar Email
scalar URL

type User {
  email: Email!
  website: URL
  createdAt: DateTime!
}</code></pre>

    <h4>Objects</h4>
    <p>The core building blocks, like <code>User</code> and <code>Post</code>, which are made up of fields.</p>

    <h4>Lists</h4>
    <p>Denoted by <code>[ ]</code>. <code>[Post]</code> means a list of <code>Post</code> objects.</p>
    <pre><code>type User {
  friends: [User!]!    # Non-null array of non-null Users
  nicknames: [String]  # Nullable array of nullable Strings
}</code></pre>

    <h4>Enums</h4>
    <p>A defined set of allowed values.</p>
    <pre><code>enum PostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

type Post {
  status: PostStatus!
}</code></pre>

    <h4>Interfaces</h4>
    <p>An abstract type that defines a set of fields. Other types must <em>implement</em> these fields.</p>
    <pre><code>interface Notification {
  id: ID!
  message: String!
}

type EmailNotification implements Notification {
  id: ID!
  message: String!
  email: String!
}</code></pre>

    <h4>Unions</h4>
    <p>A way to return one of several possible types.</p>
    <pre><code>union SearchResult = Photo | Post | User

type Query {
  search(text: String!): [SearchResult!]!
}</code></pre>

    <div class="page-break"></div>

    <h2 id="resolvers">Resolvers</h2>
    <p>Functions that fetch the actual data for schema fields.</p>

    <h3>Basic Resolver Example</h3>
    <pre><code>const resolvers = {
  Query: {
    user: (parent, args, context, info) => {
      return context.db.users.find(u => u.id === args.id);
    },
    users: (parent, args, context, info) => {
      return context.db.users.slice(args.offset, args.offset + args.limit);
    }
  },
  
  User: {
    posts: (user, args, context, info) => {
      return context.db.posts.filter(p => p.authorId === user.id);
    }
  },
  
  Mutation: {
    createUser: (parent, args, context, info) => {
      const newUser = {
        id: generateId(),
        ...args.input
      };
      context.db.users.push(newUser);
      return newUser;
    }
  }
};</code></pre>

    <h3>Resolver Function Parameters</h3>
    <ol>
        <li><strong>parent:</strong> The result of the parent resolver</li>
        <li><strong>args:</strong> Arguments provided to the field</li>
        <li><strong>context:</strong> Shared data (database, user info, etc.)</li>
        <li><strong>info:</strong> Query metadata and AST</li>
    </ol>

    <h2 id="serving-graphql">Serving GraphQL</h2>

    <h3>GraphQL Over HTTP</h3>
    <p>Standard way to serve GraphQL APIs.</p>

    <h4>HTTP Specification</h4>
    <ul>
        <li><strong>POST</strong> request with JSON body</li>
        <li>Response includes <code>data</code>, <code>errors</code>, <code>extensions</code></li>
    </ul>

    <div class="example">
        <p><strong>Request:</strong></p>
        <pre><code>POST /graphql
Content-Type: application/json

{
  "query": "{ user(id: \"123\") { name } }",
  "variables": {},
  "operationName": null
}</code></pre>

        <p><strong>Response:</strong></p>
        <pre><code>{
  "data": {
    "user": {
      "name": "John Doe"
    }
  },
  "errors": null
}</code></pre>
    </div>

    <h3>Authorization</h3>
    <p>Securing GraphQL endpoints with JWT, API keys, OAuth.</p>
    <pre><code>const resolvers = {
  Query: {
    sensitiveData: (parent, args, context) => {
      if (!context.user || !context.user.isAdmin) {
        throw new Error('Unauthorized');
      }
      return getSensitiveData();
    }
  }
};</code></pre>

    <div class="page-break"></div>

    <h2 id="pagination">Pagination</h2>

    <h3>Why Pagination?</h3>
    <p>Avoid loading all data at once, improve performance, and provide better user experience.</p>

    <h3>Cursor-based Pagination</h3>
    <p>Using cursors for stable pagination (Relay specification).</p>
    
    <pre><code>type Query {
  posts(first: Int, after: String): PostConnection!
}

type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
}

type PostEdge {
  node: Post!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}</code></pre>

    <h2 id="implementations">Implementations</h2>

    <h3>Server Implementations</h3>

    <h4>JavaScript</h4>
    <p><strong>Apollo Server</strong> - Production-ready GraphQL server:</p>
    <pre><code>import { ApolloServer } from 'apollo-server-express';
import { typeDefs, resolvers } from './schema';

const server = new ApolloServer({
  typeDefs,
  resolvers,
  context: ({ req }) => ({
    user: req.user,
    db: database
  })
});</code></pre>

    <h3>Client Implementations</h3>
    <p><strong>Apollo Client</strong> - Comprehensive caching client:</p>
    <pre><code>import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache()
});

const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
    }
  }
`;

client.query({ query: GET_USERS }).then(result => {
  console.log(result.data.users);
});</code></pre>

    <div class="page-break"></div>

    <h2 id="advanced-features">Advanced Features</h2>

    <h3>Error Handling</h3>
    <p>GraphQL has a structured way to handle errors:</p>
    <pre><code>{
  "data": {
    "user": null
  },
  "errors": [
    {
      "message": "User not found",
      "locations": [{ "line": 2, "column": 3 }],
      "path": ["user"],
      "extensions": {
        "code": "USER_NOT_FOUND",
        "userId": "123"
      }
    }
  ]
}</code></pre>

    <h3>DataLoader Pattern</h3>
    <p>Solve the N+1 query problem:</p>
    <pre><code>import DataLoader from 'dataloader';

const userLoader = new DataLoader(async (userIds) => {
  const users = await User.findByIds(userIds);
  return userIds.map(id => users.find(user => user.id === id));
});

const resolvers = {
  Post: {
    author: (post) => userLoader.load(post.authorId)
  }
};</code></pre>

    <h2 id="best-practices">Best Practices</h2>

    <h3>Schema Design</h3>
    <ol>
        <li><strong>Use descriptive names</strong> for types and fields</li>
        <li><strong>Favor object types over scalars</strong> for complex data</li>
        <li><strong>Use enums</strong> for predefined sets of values</li>
        <li><strong>Design for the client</strong>, not the database</li>
        <li><strong>Use interfaces</strong> for common fields across types</li>
    </ol>

    <h3>Security</h3>
    <ol>
        <li><strong>Implement query depth limiting</strong></li>
        <li><strong>Add query complexity analysis</strong></li>
        <li><strong>Implement rate limiting</strong></li>
        <li><strong>Sanitize inputs</strong></li>
        <li><strong>Use proper authentication and authorization</strong></li>
    </ol>

    <h3>Performance</h3>
    <ol>
        <li><strong>Use DataLoader</strong> for batching and caching</li>
        <li><strong>Implement proper caching</strong> strategies</li>
        <li><strong>Optimize database queries</strong></li>
        <li><strong>Use connection pooling</strong></li>
        <li><strong>Monitor query performance</strong></li>
    </ol>

    <div class="page-break"></div>

    <h2 id="final-takeaways">Final Takeaways</h2>

    <h3>Key Concepts Summary</h3>
    <ul>
        <li><strong>GraphQL is not just a query language</strong> — it's a full ecosystem</li>
        <li><strong>Schema-first approach</strong> ensures strong contracts between frontend and backend</li>
        <li><strong>Resolvers are the heart</strong> of the server — they map queries to real data</li>
        <li><strong>Subscriptions enable real-time apps</strong> — critical for modern applications</li>
        <li><strong>Apollo Client + Server</strong> is the most popular stack today</li>
        <li><strong>Use tools like GraphiQL</strong> to explore schema and test queries</li>
    </ul>

    <h3>Core Operation Types</h3>
    <ul>
        <li><strong>Queries</strong> = Read operations</li>
        <li><strong>Mutations</strong> = Write operations (create, update, delete)</li>
        <li><strong>Subscriptions</strong> = Live updates and real-time data</li>
    </ul>

    <h3>Essential Components</h3>
    <ul>
        <li><strong>Schema + Resolvers</strong> = API blueprint + data-fetching functions</li>
        <li><strong>Validation + Execution</strong> = Ensure correctness and fetch data</li>
        <li><strong>Transport</strong> = HTTP, WebSocket, Server-Sent Events</li>
        <li><strong>Implementations</strong> = Different server & client libraries</li>
    </ul>

    <div class="highlight">
        <h3>Key Benefits</h3>
        <ul>
            <li><strong>No over-fetching or under-fetching</strong> of data</li>
            <li><strong>Single endpoint</strong> instead of multiple REST routes</li>
            <li><strong>Strong typing</strong> with excellent tooling support</li>
            <li><strong>Real-time capabilities</strong> built-in</li>
            <li><strong>Introspection</strong> allows for powerful developer tools</li>
            <li><strong>Backward compatibility</strong> when evolving schemas</li>
        </ul>
    </div>

    <h3>When to Use GraphQL</h3>
    <div class="example">
        <p><strong>Good fit:</strong></p>
        <ul>
            <li>Complex, interconnected data</li>
            <li>Multiple client applications</li>
            <li>Rapid frontend development</li>
            <li>Real-time features needed</li>
            <li>Strong typing requirements</li>
        </ul>
    </div>

    <div class="warning">
        <p><strong>Consider alternatives:</strong></p>
        <ul>
            <li>Simple CRUD operations</li>
            <li>File uploads (though possible)</li>
            <li>Legacy system integration</li>
            <li>Small team/simple requirements</li>
        </ul>
    </div>

    <h3>Getting Started Checklist</h3>
    <ol>
        <li><strong>Define your schema</strong> with types and operations</li>
        <li><strong>Implement resolvers</strong> for data fetching</li>
        <li><strong>Set up a GraphQL server</strong> (Apollo Server recommended)</li>
        <li><strong>Choose a client library</strong> (Apollo Client for React)</li>
        <li><strong>Add error handling</strong> and validation</li>
        <li><strong>Implement authentication</strong> and authorization</li>
        <li><strong>Add monitoring</strong> and performance optimization</li>
        <li><strong>Write tests</strong> for queries, mutations, and resolvers</li>
    </ol>

    <div class="section-break"></div>
    
    <p style="text-align: center; font-style: italic; color: #6c757d;">
        This guide provides a comprehensive overview of GraphQL. For the most up-to-date information and specific implementation details, always refer to the official documentation of your chosen GraphQL implementation.
    </p>

</body>
</html>
